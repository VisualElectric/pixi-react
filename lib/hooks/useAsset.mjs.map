{"version":3,"file":"useAsset.mjs","sources":["../../src/hooks/useAsset.ts"],"sourcesContent":["import {\n    Assets,\n    Cache,\n} from 'pixi.js';\nimport { getAssetKey } from '../helpers/getAssetKey';\n\nimport type {\n    ProgressCallback,\n    UnresolvedAsset,\n} from 'pixi.js';\nimport type { AssetRetryOptions } from '../typedefs/AssetRetryOptions';\nimport type { AssetRetryState } from '../typedefs/AssetRetryState';\nimport type { ErrorCallback } from '../typedefs/ErrorCallback';\n\nconst errorCache: Map<UnresolvedAsset | string, AssetRetryState> = new Map();\n\n/** @deprecated Use `useAssets` instead. */\nexport function useAsset<T = any>(\n    /** @description Asset options. */\n    options: (UnresolvedAsset & AssetRetryOptions) | string,\n    /** @description A function to be called when the asset loader reports loading progress. */\n    onProgress?: ProgressCallback,\n    /** @description A function to be called when the asset loader reports loading progress. */\n    onError?: ErrorCallback,\n)\n{\n    if (typeof window === 'undefined')\n    {\n        /**\n         * This is a weird hack that allows us to throw the error during\n         * serverside rendering, but still causes it to be handled appropriately\n         * in Next.js applications.\n         *\n         * @see https://github.com/vercel/next.js/blob/38b3423160afc572ad933c24c86fc572c584e70b/packages/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts\n         */\n        throw Object.assign(Error('`useAsset` will only run on the client.'), {\n            digest: 'BAILOUT_TO_CLIENT_SIDE_RENDERING',\n        });\n    }\n\n    const {\n        maxRetries = 3,\n        retryOnFailure = true,\n    } = typeof options !== 'string' ? options : {};\n\n    const assetKey = getAssetKey(options);\n\n    if (!Cache.has(assetKey))\n    {\n        let state = errorCache.get(options);\n\n        // Rethrow the cached error if we are not retrying on failure or have reached the max retries\n        if (state && (!retryOnFailure || state.retries > maxRetries))\n        {\n            if (typeof onError === 'function')\n            {\n                onError?.(state.error);\n            }\n            else\n            {\n                throw state.error;\n            }\n        }\n\n        throw Assets\n            .load<T>(options, onProgress)\n            .catch((error) =>\n            {\n                if (!state)\n                {\n                    state = {\n                        error,\n                        retries: 0,\n                    };\n                }\n\n                errorCache.set(options, {\n                    ...state,\n                    error,\n                    retries: state.retries + 1,\n                });\n            });\n    }\n\n    return Assets.get<T>(assetKey);\n}\n"],"names":[],"mappings":";;;;AAcA,MAAM,UAAA,uBAAiE,GAAI,EAAA,CAAA;AAG3D,SAAA,QAAA,CAEZ,OAEA,EAAA,UAAA,EAEA,OAEJ,EAAA;AACI,EAAI,IAAA,OAAO,WAAW,WACtB,EAAA;AAQI,IAAA,MAAM,MAAO,CAAA,MAAA,CAAO,KAAM,CAAA,yCAAyC,CAAG,EAAA;AAAA,MAClE,MAAQ,EAAA,kCAAA;AAAA,KACX,CAAA,CAAA;AAAA,GACL;AAEA,EAAM,MAAA;AAAA,IACF,UAAa,GAAA,CAAA;AAAA,IACb,cAAiB,GAAA,IAAA;AAAA,GACjB,GAAA,OAAO,OAAY,KAAA,QAAA,GAAW,UAAU,EAAC,CAAA;AAE7C,EAAM,MAAA,QAAA,GAAW,YAAY,OAAO,CAAA,CAAA;AAEpC,EAAA,IAAI,CAAC,KAAA,CAAM,GAAI,CAAA,QAAQ,CACvB,EAAA;AACI,IAAI,IAAA,KAAA,GAAQ,UAAW,CAAA,GAAA,CAAI,OAAO,CAAA,CAAA;AAGlC,IAAA,IAAI,KAAU,KAAA,CAAC,cAAkB,IAAA,KAAA,CAAM,UAAU,UACjD,CAAA,EAAA;AACI,MAAI,IAAA,OAAO,YAAY,UACvB,EAAA;AACI,QAAA,OAAA,GAAU,MAAM,KAAK,CAAA,CAAA;AAAA,OAGzB,MAAA;AACI,QAAA,MAAM,KAAM,CAAA,KAAA,CAAA;AAAA,OAChB;AAAA,KACJ;AAEA,IAAA,MAAM,OACD,IAAQ,CAAA,OAAA,EAAS,UAAU,CAC3B,CAAA,KAAA,CAAM,CAAC,KACR,KAAA;AACI,MAAA,IAAI,CAAC,KACL,EAAA;AACI,QAAQ,KAAA,GAAA;AAAA,UACJ,KAAA;AAAA,UACA,OAAS,EAAA,CAAA;AAAA,SACb,CAAA;AAAA,OACJ;AAEA,MAAA,UAAA,CAAW,IAAI,OAAS,EAAA;AAAA,QACpB,GAAG,KAAA;AAAA,QACH,KAAA;AAAA,QACA,OAAA,EAAS,MAAM,OAAU,GAAA,CAAA;AAAA,OAC5B,CAAA,CAAA;AAAA,KACJ,CAAA,CAAA;AAAA,GACT;AAEA,EAAO,OAAA,MAAA,CAAO,IAAO,QAAQ,CAAA,CAAA;AACjC;;;;"}